# 132. Palindrome Partitioning II

Given a string _s_, partition _s_ such that every substring of the partition is a palindrome.

Return the minimum cuts needed for a palindrome partitioning of _s_.

**Example:**

```text
Input: "aab"
Output: 1
Explanation: The palindrome partitioning ["aa","b"] could be produced using 1 cut.
```

这里判断一个字符串是不是Palindrome的时候用

```text
s.charAt(i) == s.charAt(j) && (j - i< 2 || p[i + 1][j - 1])
```

这个和647的方法一样，从后往前退，所以最后求的是dp\[0\].

dp\[i\]表示从n到i的字符串的分割次数。

时间复杂度：O\(n^2\)

空间复杂度: O\(n^2\)

```text
class Solution {
    public int minCut(String s) {
        if (s == null || s.length() == 0)
            return 0;
        int n = s.length();
        int[] dp = new int[n];
        boolean[][] p = new boolean[n][n];
        for (int i = n - 1; i >= 0; i--) {
            dp[i] = n - i - 1;
            for (int j = i; j < n; j++) {
                if (s.charAt(i) == s.charAt(j) && (j - i< 2 || p[i + 1][j - 1])) {
                    p[i][j] = true;
                    dp[i] = (j == n - 1) ? 0 : Math.min(dp[i], dp[j + 1] + 1);
                }
            }
        }
        return dp[0];
    }
}
```

